// src/core/output/outputStyleDecorate.ts
import type { KubeAggregatorConfigMerged } from '../../config/configSchema.js'; // Renamed

// Analyze the configuration to determine what was included/excluded/processed.
// This needs significant adaptation for Kubernetes filters.
interface ContentInfo {
  selection: {
    allNamespaces: boolean; // Example adaptation
    filteredNamespaces?: string[];
    resourceTypes?: string[];
    labelSelector?: string;
    fieldSelector?: string;
  };
  processing: {
    secretsRedacted: boolean;
    // Add other processing flags later
  };
}

// Adapt this function to reflect Kubernetes filtering logic
export const analyzeContent = (config: KubeAggregatorConfigMerged): ContentInfo => {
  return {
    selection: {
      allNamespaces: !config.filter?.namespaces?.length,
      filteredNamespaces: config.filter?.namespaces,
      resourceTypes: config.filter?.includeResourceTypes, // Simplified for now
      labelSelector: config.filter?.labelSelector,
      fieldSelector: config.filter?.fieldSelector,
    },
    processing: {
      secretsRedacted: config.security?.redactSecrets ?? true, // Default to true
    },
  };
};

// Adapt the header generation based on Kubernetes context
export const generateHeader = (config: KubeAggregatorConfigMerged, generationDate: string): string => {
  const info = analyzeContent(config);
  let description = 'This file is an aggregated representation of Kubernetes resources from the cluster';

  if (
    !info.selection.allNamespaces ||
    info.selection.resourceTypes?.length ||
    info.selection.labelSelector ||
    info.selection.fieldSelector
  ) {
    description += ', potentially filtered by namespace, resource type, or selectors';
  }

  const processingNotes = [];
  if (info.processing.secretsRedacted) {
    processingNotes.push('Secret data has been redacted');
  }
  // Add other processing notes later

  const processingInfo = processingNotes.length > 0 ? `Processing notes: ${processingNotes.join(', ')}.` : '';

  return `${description}, generated by KubeAggregator on ${generationDate}.\n${processingInfo}`.trim();
};

// Adapt the purpose description
export const generateSummaryPurpose = (): string => {
  return `
This file contains an aggregated representation of Kubernetes resources from a cluster.
It is designed to be easily consumable by AI systems for cluster analysis, troubleshooting,
or other automated processes requiring cluster state information.
`.trim();
};

// Adapt the file format description
export const generateSummaryFileFormat = (): string => {
  return `
The content is organized as follows:
1. This summary section
2. Cluster information (context, etc. - placeholder)
3. Cluster Resource Overview (e.g., list of namespaces)
`.trim(); // Step 4 added dynamically in templates
};

// Adapt usage guidelines
export const generateSummaryUsageGuidelines = (
  config: KubeAggregatorConfigMerged,
  repositoryInstruction: string,
): string => {
  return `
- This file contains potentially sensitive cluster configuration details. Handle it securely.
- Resource definitions might be filtered based on the tool's configuration.
- When processing this file, use the resource kind, name, and namespace to distinguish
  between different resources.
`.trim();
};

// Adapt notes based on Kubernetes context and filtering
export const generateSummaryNotes = (config: KubeAggregatorConfigMerged): string => {
  const info = analyzeContent(config);
  const notes: string[] = [
    '- Resource fetching depends on the Kubernetes context and permissions used to run the tool.',
  ];

  // Selection notes
  const filter = config.filter || {};

  if (info.selection.filteredNamespaces?.length) {
    notes.push(`- Only resources from these namespaces are included: ${info.selection.filteredNamespaces.join(', ')}`);
  } else if (!info.selection.allNamespaces) {
    // This case might need refinement based on how namespace filtering is fully implemented
    notes.push('- Resources might be filtered by namespace based on configuration.');
  }

  if (filter.excludeNamespaces?.length) {
    notes.push(`- Namespaces excluded: ${filter.excludeNamespaces.join(', ')}`);
  }

  if (info.selection.resourceTypes?.length) {
    notes.push(`- Included resource types: ${info.selection.resourceTypes.join(', ')}`);
  }

  if (filter.excludeResourceTypes?.length) {
    notes.push(`- Excluded resource types: ${filter.excludeResourceTypes.join(', ')}`);
  }

  if (info.selection.labelSelector) {
    notes.push(`- Resources filtered by label selector: ${info.selection.labelSelector}`);
  }
  if (info.selection.fieldSelector) {
    notes.push(`- Resources filtered by field selector: ${info.selection.fieldSelector}`);
  }

  // Processing notes
  if (info.processing.secretsRedacted) {
    notes.push('- Sensitive data within Secret resources has been redacted.');
  }

  return notes.join('\n');
};
